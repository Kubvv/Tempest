

module Syntax.AbsTempest where

-- Haskell module generated by the BNF converter

newtype Ident = Ident String deriving (Eq, Ord, Show, Read)

data Program a = PProgram a [Def a]
  deriving (Eq, Ord, Show, Read)

instance Functor Program where
    fmap f x = case x of
        PProgram a defs -> PProgram (f a) (map (fmap f) defs)


data Def a
    = FnDef a (Type a) Ident [Arg a] (Block a)
    | GlDef a (Type a) Ident (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor Def where
    fmap f x = case x of
        FnDef a type_ ident args block -> FnDef (f a) (fmap f type_) ident (map (fmap f) args) (fmap f block)
        GlDef a type_ ident expr -> GlDef (f a) (fmap f type_) ident (fmap f expr)


data Arg a = VArg a (Type a) Ident | RArg a (Type a) Ident
  deriving (Eq, Ord, Show, Read)

instance Functor Arg where
    fmap f x = case x of
        VArg a type_ ident -> VArg (f a) (fmap f type_) ident
        RArg a type_ ident -> RArg (f a) (fmap f type_) ident


data Block a = BBlock a [Stmt a]
  deriving (Eq, Ord, Show, Read)

instance Functor Block where
    fmap f x = case x of
        BBlock a stmts -> BBlock (f a) (map (fmap f) stmts)


data Stmt a
    = SEmpty a
    | SBStmt a (Block a)
    | SInit a (Def a)
    | SAss a Ident (Expr a)
    | SIncr a Ident
    | SDecr a Ident
    | SRet a (Expr a)
    | SVRet a
    | SCond a (Expr a) (Block a)
    | SCondElse a (Expr a) (Block a) (Block a)
    | SWhile a (Expr a) (Block a)
    | SExp a (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor Stmt where
    fmap f x = case x of
        SEmpty a -> SEmpty (f a)
        SBStmt a block -> SBStmt (f a) (fmap f block)
        SInit a def -> SInit (f a) (fmap f def)
        SAss a ident expr -> SAss (f a) ident (fmap f expr)
        SIncr a ident -> SIncr (f a) ident
        SDecr a ident -> SDecr (f a) ident
        SRet a expr -> SRet (f a) (fmap f expr)
        SVRet a -> SVRet (f a)
        SCond a expr block -> SCond (f a) (fmap f expr) (fmap f block)
        SCondElse a expr block1 block2 -> SCondElse (f a) (fmap f expr) (fmap f block1) (fmap f block2)
        SWhile a expr block -> SWhile (f a) (fmap f expr) (fmap f block)
        SExp a expr -> SExp (f a) (fmap f expr)


data Type a
    = TInt a | TStr a | TBool a | TVoid a | TFun a (Type a) [Type a]
  deriving (Eq, Ord, Show, Read)

instance Functor Type where
    fmap f x = case x of
        TInt a -> TInt (f a)
        TStr a -> TStr (f a)
        TBool a -> TBool (f a)
        TVoid a -> TVoid (f a)
        TFun a type_ types -> TFun (f a) (fmap f type_) (map (fmap f) types)


data Expr a
    = EVar a Ident
    | ELitInt a Integer
    | ELitTrue a
    | ELitFalse a
    | EApp a Ident [Expr a]
    | EString a String
    | ENeg a (Expr a)
    | ENot a (Expr a)
    | EMul a (Expr a) (MulOp a) (Expr a)
    | EAdd a (Expr a) (AddOp a) (Expr a)
    | ERel a (Expr a) (RelOp a) (Expr a)
    | EAnd a (Expr a) (Expr a)
    | EOr a (Expr a) (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor Expr where
    fmap f x = case x of
        EVar a ident -> EVar (f a) ident
        ELitInt a integer -> ELitInt (f a) integer
        ELitTrue a -> ELitTrue (f a)
        ELitFalse a -> ELitFalse (f a)
        EApp a ident exprs -> EApp (f a) ident (map (fmap f) exprs)
        EString a string -> EString (f a) string
        ENeg a expr -> ENeg (f a) (fmap f expr)
        ENot a expr -> ENot (f a) (fmap f expr)
        EMul a expr1 mulop expr2 -> EMul (f a) (fmap f expr1) (fmap f mulop) (fmap f expr2)
        EAdd a expr1 addop expr2 -> EAdd (f a) (fmap f expr1) (fmap f addop) (fmap f expr2)
        ERel a expr1 relop expr2 -> ERel (f a) (fmap f expr1) (fmap f relop) (fmap f expr2)
        EAnd a expr1 expr2 -> EAnd (f a) (fmap f expr1) (fmap f expr2)
        EOr a expr1 expr2 -> EOr (f a) (fmap f expr1) (fmap f expr2)


data AddOp a = OAdd a | OSub a
  deriving (Eq, Ord, Show, Read)

instance Functor AddOp where
    fmap f x = case x of
        OAdd a -> OAdd (f a)
        OSub a -> OSub (f a)


data MulOp a = OMul a | ODiv a | OMod a
  deriving (Eq, Ord, Show, Read)

instance Functor MulOp where
    fmap f x = case x of
        OMul a -> OMul (f a)
        ODiv a -> ODiv (f a)
        OMod a -> OMod (f a)


data RelOp a = OLs a | OLe a | OGr a | OGe a | OEq a | ONe a
  deriving (Eq, Ord, Show, Read)

instance Functor RelOp where
    fmap f x = case x of
        OLs a -> OLs (f a)
        OLe a -> OLe (f a)
        OGr a -> OGr (f a)
        OGe a -> OGe (f a)
        OEq a -> OEq (f a)
        ONe a -> ONe (f a)
